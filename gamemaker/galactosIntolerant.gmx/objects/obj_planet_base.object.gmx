<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// show info text on hover
if (position_meeting(mouse_x, mouse_y, id))
{
    showtext = 0;
    self.image_index = 1;
}
else 
{
    showtext = 0; 
    self.image_index = 0;
}

//--------------------------------------------------------- SCORE
if(self.do_action &gt; -1)
{
    global.score -= round(random_range(200000000, 50000000));
    if (global.score &lt; 0)
        global.score = 0;
}

//--------------------------------------------------------- TURNS
if (self.turn &lt; global.turn)
{
    // work out the steps
    new_step = self.step + self.rate;

    // run the calc script
    scr_calculateOrbit(self.id, new_step);

    // store new step
    self.step = new_step;
    self.action_lock = true;
    self.turning = true;
    self.turn +=1
}
    
//--------------------------------------------------------- ACTIONS
if(self.do_action == 0 || self.do_action == 1)
{
    // work out the steps
    if (self.do_action == 0) // move forward
    {
        new_step = self.step + self.rate;
    }
    else if (self.do_action == 1) // move back
    {
        new_step = self.step - self.rate;
    }
    // run the calc script
    scr_calculateOrbit( self.id, new_step );

    // store new step
    self.step = new_step
    self.do_action = -1;
    self.action_lock = true
}  

if(self.do_action == 2 || self.do_action == 3)
{
    self.do_action = -1;
}
    
//--------------------------------------------------------- ORBITING
if (self.orbit_deg != 0)
{   
    // Calculate degrees of movement for this step
    self.current_degrees += self.orbit_incr;
    self.orbit_deg -= self.orbit_incr;
    
    // make the planet orbit
    scr_setPlanetOrbit(self.id, self.current_degrees);
    
    // if this is the last step of animation, turn off the lock
    if self.orbit_deg == 0
    {   
        if (self.turning == true)     
        {
            self.turning = false
        }
        else
        {
            global.need_turn = true
        }
        self.action_lock = false;
    }
    
    // roate planet and set facing
    self.image_angle += self.day_cycle;
}


//--------------------------------------------------------- MOVING FOR SWAP
if (self.move_dist &gt; 0)
{
    // get distance to target
    diff_x = self.move_x - self.x;
    diff_y = self.move_y - self.y; 

    //calculate length
    length = sqrt((diff_x*diff_x)+(diff_y*diff_y));

    // normalise the distance
    norm_x = diff_x / length;
    norm_y = diff_y / length;
    
    // add the calculated vector onto the current position
    self.x = self.x + (norm_x * self.move_incr);
    self.y = self.y + (norm_y * self.move_incr);
    
    // count down the total distance
    self.move_dist -= self.move_incr;
    
    // if this is the last step of animation, turn off the lock
    if self.move_dist == 0
    {
        global.need_turn = true;
        global.swap_mode = 0;
        global.swap_from = -1;
        global.swap_to = -1;
        self.action_lock = false;
        
        self.move_x = 0;
        self.move_y = 0;
    }  
    // roate planet
    self.image_angle += self.day_cycle;
}

//--------------------------------------------------------- KONAMI CODE

if (global.konami == 1)
{
    // run the calc script
    new_step = global.orb_step_arr[planet.orbit] - planet.rate
    scr_calculateOrbit(self.id, new_step);
    
    // store new step
    self.step = new_step;
    global.need_turn = true;
    self.action_lock = true;
}

//--------------------------------------------------------- POST-ANIMA

self.facing = point_direction(obj_sun.x, obj_sun.y, self.x, self.y);









</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//--------------------------------------------------------- ARROW DISPLAY

// display arrows if there aren't any open already
// otherwise trigger planet swap
if (!global.arrows_visible &amp;&amp; !global.swap_mode &amp;&amp; !scr_action_locked()) 
{  
    r = sprite_width * 0.5;
    ang = id.facing;
    
    // forward
    inst0 = instance_create( x, y, obj_arrow_base );
    self.arrows[0] = inst0;
    inst0.parentid = id;
    inst0.image_angle = ang+90;
    inst0.sprite_index = global.spr_arrow_arr[0];
    inst0.type = 0; // left
        
    // back
    inst1 = instance_create( x, y, obj_arrow_base );
    self.arrows[1] = inst1;
    inst1.parentid = id;
    inst1.image_angle = ang-90;
    inst1.sprite_index = global.spr_arrow_arr[1];
    inst1.type = 1; // right
    
    // swapping
    if (id.orbit != 5)
    {
        inst2 = instance_create( x, y, obj_arrow_base );
        self.arrows[2] = inst2;
        inst2.parentid = id;
        inst2.image_angle = ang;
        inst2.sprite_index = global.spr_arrow_arr[2];
        inst2.type = 2; // up 
    }
    
    if (id.orbit != 0)
    {
        inst3 = instance_create( x, y, obj_arrow_base );
        self.arrows[3] = inst3;
        inst3.parentid = id;
        inst3.image_angle = ang-180;
        inst3.sprite_index = global.spr_arrow_arr[3];
        inst3.type = 2; // down
    }


}

//--------------------------------------------------------- SWAPPING 

if (global.swap_mode == 1)
{
    //if (global.swap_from == self.id)
    //    return  
    my_orbit = self.orbit
    my_step  = self.step
    
    self.orbit = global.swap_from.orbit;
    self.step  = global.swap_from.step;
    
    global.swap_from.orbit = my_orbit;
    global.swap_from.step  = my_step ;

    // animation data for other planet 
    global.swap_from.move_x = self.x 
    global.swap_from.move_y = self.y 

    dist = point_distance(self.x, self.y, global.swap_from.x, global.swap_from.y) 
    incr = dist / global.anim_time
    
    global.swap_from.move_dist =  dist
    global.swap_from.move_incr =  incr
    
    // animation data for self
    self.move_x = global.swap_from.x 
    self.move_y = global.swap_from.y 
    self.move_dist =  dist
    self.move_incr =  incr
}


/*
// swap self
degrees = global.orbit_deg_arr[self.orbit] * self.step;
radius = global.sun_radius + (self.orbit * global.orb_width);
self.x = (room_width/2)+global.offset_x + (radius * (sin(degtorad(global.offset_rotation + degrees))));
self.y = (room_height/2)+global.offset_y + (radius * (cos(degtorad(global.offset_rotation + degrees))));

// swap remote
degrees = global.orbit_deg_arr[global.swap_from.orbit] * global.swap_from.step;
radius = global.sun_radius + (global.swap_from.orbit * global.orb_width);
global.swap_from.x = (room_width/2)+global.offset_x + (radius * (sin(degtorad(global.offset_rotation + degrees))));
global.swap_from.y = (room_height/2)+global.offset_y + (radius * (cos(degtorad(global.offset_rotation + degrees))));
  
// cleanup
global.swap_mode = 0;
global.swap_from = -1;
global.action_lock = 0;
global.turn +=1;
*/

    












</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// click sounds
snd = audio_play_sound(snd_click, 100, false);
audio_sound_gain(snd, global.snd_fx, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initial position
degrees = global.orbit_deg_arr[self.orbit] * self.step
script_execute(scr_setPlanetOrbit, self.id, degrees);

// move/swap planet [-1-off; 0-left, 1-right, 2-up, 3-down]
self.do_action = -1;

// hover info text
showtext = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

//show_debug_message(string(self.wikitext));
if (showtext == 1)
{
    draw_text(x, y-64, "=====Hi!#This is information for:#"+object_get_name(id.object_index)+" #"+string(self.name));

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
